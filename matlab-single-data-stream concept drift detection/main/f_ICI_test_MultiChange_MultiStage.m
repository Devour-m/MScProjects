function [confirmedDetections, originalDetections, dimensionDetected, tsEnd, tsInit, tsLengths, testDetectingChange] = f_ICI_test_MultiChange_MultiStage(DataSet, tsLength_init, params, PCAactive,PCApercent)
% 
% function [tsEnd, tsInit, confirmedDetections, tsLengths , testDetectingChange, originalDetections] = f_ICI_test_MultiChange_MultiStage(DataSet , tsLength_init , params)
% 
% input description
% 
% DataSet              a row vector containing the sequence of scalar data to be analyzed (data are analyzed in an online, sequential way)
% tsLength_init     initial length of the training set, this may differ from the training set size defined runtime after
%                            each detection.
% params 		      the parameter structure for the test. This can be generated by the function define_ICI_test_parameters()
%                            that sets the default parameters
% 
% output description
% 
% tsEnd                                  vector of the detected change-time instants: i.e max([\hat{T}, T_{ref} + params.MinimumTS_Size]). 
%                                               when detections are not validated by the second layer this vector
%                                               contains repeated values.  Note that the output of the first layer CDT
%                                               are in the vector confirmedDetections (third argument), and values of
%                                               tsEnd are often delayed to gather at least params.MinimumTS_Size
%                                               observations after the prospective change.
%                                               tsInit(1) = tsLength_init as it corresponds to the initial training set
% tsInit                                   vector of refined change-time instants (i.e T_{ref}). 
%                                               when detections are not validated by the second layer this vector
%                                               contains repeated values.
%                                               tsInit(1) = 1 as it corresponds to the initial training set
% confirmedDetections       vector of the estimated change time instant from the first layer implementing 
%                                               algorithm in [1]. Thus, only CDT detections validated by the Hotelling T^2 
%                                               hypothesis test are here reported. 
%                                              IMPORTANT REMARK: we do not impose any minimum distance between tsInit and
%                                               confirmedDetections. However, a minimum number of observations is required 
%                                               between tsInit and tsEnd, to validate the change and possibly reconfigure the CDT.
%                                               When CDT have to be assessed on a sequence of changes, then tsEnd
%                                               should be taken into account.
% tsLengths                         vector lengts of each trainig set (i.e for each change \hat{T} - T_{ref})
% testDetectingChange      struct containing index of features of ICI-based CDT detecting the change (1 or 2)
%                                               - testDetectingChange.Init     CDT that provided the first detection (\hat{T})
%                                               - testDetectingChange.Refined  CDT providing the refined estimate (T_{ref})
% originalDetections          detection of ICI-based CDT without validation: it corresponds to the detections raised by
%                                            the ICI-based CDT in [3]. When there are no false positives,
%                                            originalDetections and confirmedDetections do coincide
% 
% 
% Giacomo Boracchi
% Politecnico di Milano
% January 2011
% giacomo.boracchi@polimi.it
%
% please cite this work as
%
% [1] Cesare Alippi, Giacomo Boracchi, Manuel Roveri,
% "Hierarchical Change-Detection Tests"
% IEEE Transactions on Neural Networks and Learning Systems, In Press (2016), 13 pages doi:10.1109/TNNLS.2015.2512714 
%
% [2] Cesare Alippi, Giacomo Boracchi and Manuel Roveri
% "Change Detection Tests Using the ICI rule"
% in Proceedings of IJCNN 2010, the International Joint Conference on Neural Networks 18 - 23 July, 2010 Barcelona, Spain.
%
% [3]  Cesare Alippi, Giacomo Boracchi and Manuel Roveri,
% "A just-in-time adaptive classification system based on the intersection of confidence intervals rule," 
% Neural Networks, Elsevier vol. 24 (2011), pp. 791-800 doi: 10.1016/j.neunet.2011.05.012 
%
% Revision History
% December 2010 -   changed input: passing test parameter structure
% September 2013 -  added validation for change in the proportions (Bernoulli sequences)
% November 2013 -  introduced do_validate_changes and do_stop_first_detection
% December 2013 -  Engineering after changeing f_ICI_test_MultiDim (introduced point-wise processing)


detected = 1;
counter = 1;
testDetectingChange = [];
dimensionDetected =[];
p_vals = [];
h_vals = [];

DataSetReduced = DataSet;
DataSetStartIndex = 0;
confirmedDetections = [];

tsInit = 1;
tsEnd = tsLength_init;
tsLengths = tsLength_init;
originalDetections = tsInit;

% due to plugging-in the training set when the HT discards FP
offset = 0;
if PCAactive==1
    DSRTrain  = DataSetReduced(:,1:tsLengths(counter));
    demDSRTrain = DSRTrain(1:end-1,:)'- mean(DSRTrain(1:end-1,:)');
    [coeff,~,~,~,explained] = pca(demDSRTrain);
    
    for i = 1:length(explained)
        S(i) = sum(explained(1:i));
    end
    nPCA = find(S>PCApercent, 1 );
    newRDat = DataSetReduced(1:end-1,:)'*coeff(:,1:nPCA);
    DataSetReduced = [newRDat'; DataSetReduced(end,:)];
end


% change detection is iterated untill no change is detected (i.e. we reached the end of DataSet)
while(detected(counter) ~= 0)

    counter = counter + 1;
    
    % detect change on DataSetReduced using the trainig previously identified
    [detected(counter) , testDetectingChangeInit(counter) , Theta0 , dimensionDetected(counter)] = ...
        f_ICI_test_MultiDim(DataSetReduced , tsLengths(counter - 1) , params);
    
    %     disp([num2str(counter) , '  ' , num2str(detected(counter)) , '  ' , num2str(tsInit(counter - 1))]);
    
    if (detected(counter) > 0) 
        %size(DataSetReduced)
        %detected(counter) 
        %dimensionDetected(counter)
        %tsLengths(counter - 1)
        
        % run the refinement procedure to identify a new Training set

        [refined(counter) , testDetectingChange_temp] = f_ICI_refine_test(DataSetReduced, detected(counter), dimensionDetected(counter), tsLengths(counter - 1), params);
        
        testDetectingChangeRefinement(counter) = testDetectingChange_temp(max([length(testDetectingChange_temp) - 1 , 1]));
        if params.MinimumTS_Size > 0
            % update detection within the original DataSet
            tsLengths(counter) = ceil((detected(counter) - refined(counter)) / params.windowWidth) * params.windowWidth;
            tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
            %tsLengths
        else
            % in case no minimum training set is required, we expect no configuration is required. Then, no need to take
            % a training set proportional to the window.
            tsLengths(counter) = detected(counter) - refined(counter);
        end
        
        % prende l'inizio del TS alla refinement
        % remove offset, the size of the possibly added TS
      
        tsInit(counter) = DataSetStartIndex + refined(counter) - offset;
        
        % prende almeno params.MinimumTS_Size a partire da  tsInit
        tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
        
        % detection originally raised by the CDT (before and without validation)
        originalDetections(counter) = DataSetStartIndex + detected(counter) - offset;
        
        if params.do_stop_first_detection && params.do_validate_changes == 0
            confirmedDetections = [originalDetections(counter)];
            return; % the first detection has been found. Stop the CDT as no validation is required
        end
            
        %% hierarchical procedure, run batch hypothesis test
        % partition DataSet to perform hyopothesis test 
        if (tsInit(counter - 1) == 1)
            oldTS_Init = 1; % primo sample del DataSet, parte da quello
        else
            oldTS_Init = tsInit(counter - 1) + 1; % non siamo al primo dataset, parte da un sample dopo la detectin precedente
        end
        
        if (strcmpi(params.HT_Partition , 'TrainingSet'))
            oldTS_End = tsEnd(counter - 1);
        end
        
        if (strcmpi(params.HT_Partition , 'DataSet'))
            oldTS_End = tsInit(counter);
        end

        newTS_Init =  tsInit(counter) + 1;
	 	newTS_End =  tsEnd(counter);

        oldTS = DataSet(: , oldTS_Init : oldTS_End);
        newTS = DataSet(: , newTS_Init : newTS_End);
        
        
        
        
        if (length(newTS) >= params.MinimumTS_Size)
                        
            if(strcmpi(params.HT_Name , 'ztest'))
                % run z test on the sample means
                m1 = mean(oldTS);
                s1 = var(oldTS)/ length(oldTS);
                
                m2 = mean(newTS);
                s2 = var(newTS) / length(newTS);
                
                [h_test , p_val] = ztest(m1 - m2 , 0 , sqrt(s1 + s2) , params.alpha);
            end
            
            if (strcmpi(params.HT_Name , 'KolmogorovSmirnov'))
                [h_test , p_val] = kstest2(oldTS , newTS , params.alpha);
            end
            
            if strcmpi(params.HT_Name, 'Proportions') 
                      [h_test, p_val] = validateChanges_err(DataSet , oldTS_Init, oldTS_End, newTS_Init, newTS_End, params.alpha);
            end
            
            if (strcmpi(params.HT_Name , 'Multivariate') || strcmpi(params.HT_Name , 'Hotelling') )
                [h_test, p_val] = validateChanges_Data(DataSet, testDetectingChangeInit(counter), oldTS_Init, oldTS_End, newTS_Init, newTS_End, params);
            end
            
            if (strcmpi(params.HT_Name, 'Lepage') || strcmpi(params.HT_Name, 'Mann-Whitney'))
                % in case of Lepage CPM we take newTS_End  as the original detection (no delays)
                % and tsInit such that DataSet(newTS_Init : newTS_End) has the same size of DataSet(oldTS_Init : oldTS_End)
                newTS_End = originalDetections(counter);
                newTS_Init = originalDetections(counter) - (oldTS_End - oldTS_Init);
                % just to avoid including the same samples twice
                newTS_Init = max([newTS_Init, oldTS_End]);
                
                DataToCheck = DataSet([oldTS_Init : oldTS_End, newTS_Init : newTS_End]);
                
                [h_test, p_val, T_ref] = validateChanges_CPM(DataToCheck, params.cpmParams);
                
                % CPM does not require partitioning of the data sequence to be analyzed therefore, if the change is validated
                if h_test == 1
                    % we update tsInit (using \tau) provided by CPM
                    tsInit(counter) = originalDetections(counter) - (size(DataToCheck, 2) - T_ref);
                    % we update tsEnd as the original detection. Require a minimum tsLength of at least the windowSize 
                    tsEnd(counter) = max([originalDetections(counter), tsInit(counter) + params.windowWidth]);
                    % we update tsEnd as the original detection, no minimum TsLengh required for validation
                    tsLengths(counter) = tsEnd(counter) - tsInit(counter);
                    % TODO: fixme in case the minimum TS is requred for reconfiguration of the CDT
                end
            end
            
            h_vals(counter) = h_test;
            p_vals(counter) = p_val;
        else
            h_test = 1;
            h_vals(counter) = NaN;
            p_vals(counter) = NaN;
        end
        
        %% Check Validation Results
        
        if h_test == 1 || (params.do_validate_changes == 0)
            % cdt and ht agree: Change is Validated
            % update DataSet and TrainigSet. (the traning set has to be in front of the valitation set)
            DataSetStartIndex = tsInit(counter);
            DataSetReduced = DataSet(: , DataSetStartIndex + 1 : end);

            %�µ�dataset �Ǵ�refined point��ʼ�������к����
            offset = 0;
            
            confirmedDetections = [confirmedDetections , originalDetections(counter)];
            
            
            if params.do_stop_first_detection
                return;
            end
            
        else
            %Change is NOT Validated. We rely on the HT, discard detection and reconfigure detection from CDT
            detected(counter) = -1;
            
            
            % update DataSet and TrainigSet.
            if (tsInit(counter - 1) == 1)
                oldTS = DataSet(: , tsInit(counter - 1) : tsEnd(counter - 1));
            else
                oldTS = DataSet(: , tsInit(counter - 1) + 1 : tsEnd(counter - 1));
            end
            
            DataSetStartIndex = tsEnd(counter); % absolute index
            % or alternatively
            % DataSetStartIndex = tsInit(counter); % questo ?sbagliato!
            % potrebbe non finire mai!!!! ����� ������Զ���������
            
            % con questa manovra sto scazzando i riferimenti in tsInit e tsEnd
            DataSetReduced = [oldTS , DataSet(: , DataSetStartIndex + 1 : end)];
            
            % update fields to keep track of the discarded FP
            tsInit(counter) = tsInit(counter - 1);
            tsEnd(counter) = tsEnd(counter - 1);
            tsLengths(counter) = tsLengths(counter - 1);
%             originalDetections(counter) = originalDetections(counter - 1);  % mantengo quelle originali, almeno il
%             primo output ?quello senza validazione   ����ԭ�еģ����ٵ�һ���������û����֤
            % compute the number of samples added to the dataSet
            % �൱�ڸ�full dataset ������ offset �������
             %�� ��dataset �Ǵ�refined point��ʼ����detected ֮�������data �м���һ������������
            offset = size(oldTS , 2);
        end
        
        % TODO Add reconfiguration phase where we check if the number of
        % samples in the new ts is enough, otherwise we postpone the
        % detection and run another CPM to make sure that all this segment
        % is stationary
        
        
        if (length(DataSetReduced) <=  tsLengths(counter) ||  isempty(DataSetReduced))
            detected(counter) = 0;
            %warning('Sollevo un falso negativo perch?il dataset corrisponde al ts')
        else
            if PCAactive==1
                DSRTrain  = DataSetReduced(:,1:tsLengths(counter));
                demDSRTrain = DSRTrain(1:end-1,:)'- mean(DSRTrain(1:end-1,:)');
                [coeff,~,~,~,explained] = pca(demDSRTrain);
                
                for i = 1:length(explained)
                    S(i) = sum(explained(1:i));
                end
                nPCA = find(S>PCApercent, 1 );
                newRDat = DataSetReduced(1:end-1,:)'*coeff(:,1:nPCA);
                DataSetReduced = [newRDat'; DataSetReduced(end,:)];
            end
        end
        
        
    end
        
        
end

% controllo se per caso non ho avuto una detection proprio all'ultimo campione per cui non posso deifinire il ts
if tsEnd(end) == length(DataSet)
    tsInit = tsInit(1 : end);
    tsEnd = tsEnd(1 : end);
    tsLengths = tsLengths(1 : end);
    testDetectingChange = testDetectingChange(1 : end - 1);
end

if exist('testDetectingChangeRefinement', 'var')
    testDetectingChangeInit(detected < 0) = - testDetectingChangeInit(detected < 0);
    testDetectingChange.Init = testDetectingChangeInit;
    testDetectingChangeRefinement(detected < 0) = - testDetectingChangeRefinement(detected < 0);
    testDetectingChange.Refined= testDetectingChangeRefinement;
end
