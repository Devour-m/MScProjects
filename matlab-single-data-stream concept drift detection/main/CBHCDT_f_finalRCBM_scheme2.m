function [confirmedDetections,originalDetections, dimensionDetected, ClassDetected, tsEnd, tsEnd0, tsEnd1, tsInit, tsInit0, tsInit1, tsLengths, tsLengths0, tsLengths1, testDetectingChange] = CBHCDT_f_finalRCBM_scheme2(ker, nF, ts, DataSet,  tsLength_init, params)% Refine on respective data set




% Refine on respective data set
%


% function [tsEnd, tsInit, confirmedDetections, tsLengths , testDetectingChange, originalDetections] = f_ICI_test_MultiChange_MultiStage(DataSet , tsLength_init , params)
%
% input description
%
% DataSet              a row vector containing the sequence of scalar data to be analyzed (data are analyzed in an online, sequential way)
% tsLength_init     initial length of the training set, this may differ from the training set size defined runtime after
%                            each detection.
% params 		      the parameter structure for the test. This can be generated by the function define_ICI_test_parameters()
%                            that sets the default parameters
%
% output description
%
% tsEnd                                  vector of the detected change-time instants: i.e max([\hat{T}, T_{ref} + params.MinimumTS_Size]).
%                                               when detections are not validated by the second layer this vector
%                                               contains repeated values.  Note that the output of the first layer CDT
%                                               are in the vector confirmedDetections (third argument), and values of
%                                               tsEnd are often delayed to gather at least params.MinimumTS_Size
%                                               observations after the prospective change.
%                                               tsInit(1) = tsLength_init as it corresponds to the initial training set
% tsInit                                   vector of refined change-time instants (i.e T_{ref}).
%                                               when detections are not validated by the second layer this vector
%                                               contains repeated values.
%                                               tsInit(1) = 1 as it corresponds to the initial training set
% confirmedDetections       vector of the estimated change time instant from the first layer implementing
%                                               algorithm in [1]. Thus, only CDT detections validated by the Hotelling T^2
%                                               hypothesis test are here reported.
%                                              IMPORTANT REMARK: we do not impose any minimum distance between tsInit and
%                                               confirmedDetections. However, a minimum number of observations is required
%                                               between tsInit and tsEnd, to validate the change and possibly reconfigure the CDT.
%                                               When CDT have to be assessed on a sequence of changes, then tsEnd
%                                               should be taken into account.
% tsLengths                         vector lengts of each trainig set (i.e for each change \hat{T} - T_{ref})
% testDetectingChange      struct containing index of features of ICI-based CDT detecting the change (1 or 2)
%                                               - testDetectingChange.Init     CDT that provided the first detection (\hat{T})
%                                               - testDetectingChange.Refined  CDT providing the refined estimate (T_{ref})
% originalDetections          detection of ICI-based CDT without validation: it corresponds to the detections raised by
%                                            the ICI-based CDT in [3]. When there are no false positives,
%                                            originalDetections and confirmedDetections do coincide

% Revision History
% December 2010 -   changed input: passing test parameter structure
% September 2013 -  added validation for change in the proportions (Bernoulli sequences)
% November 2013 -  introduced do_validate_changes and do_stop_first_detection
% December 2013 -  Engineering after changeing f_ICI_test_MultiDim (introduced point-wise processing)


% DataSet: original data set with label
% DataSet0: original class 0 data set with label
% DataSet1: original class 1 data set with label

% label: label of original length

% DataSetReduced: samples left for training and inspection (excluding label), becomes shorter after each detection
% DataSetReduced0: class 0 samples, becomes shorter after each detection
% DataSetReduced1: class 1 samples, becomes shorter after each detection

% DataSetStartIndex: the time stamp where inspection starts, i.e., after training instances

% lab: label of instances in DataSetReduced, becomes shorter after each detection
% nc: number of classes (assume it is known that only two classes are present. Feb 2020)


% RSVMdatReduced: DataSetReduced projected onto subspace (with label)

nc = length(unique(DataSet(end,:)));
label = DataSet(end,:);

detected = 1;
DataSetReduced = DataSet(1:end-1,:);
lab = label;
DataSetStartIndex = 0;
tsLengths = tsLength_init;
tsInit = 1;
tsEnd = tsLength_init;
% due to plugging-in the training set when the HT discards FP
offset = 0;
for c = 1:nc
    eval(['detectedCB', num2str(c-1),'=','1',';']);
    eval(['DataSet',num2str(c-1),'=','DataSet(:,DataSet(end,:)==c-1)',';']);
    eval(['lab',num2str(c-1),'=','DataSet',num2str(c-1),'(end,:);']);
    eval(['DataSetStartIndex',num2str(c-1),'= 0;']);
    eval(['DataSetReduced',num2str(c-1),'=','DataSet',num2str(c-1),'(1:end-1,:);']);
    eval(['tsLengths',num2str(c-1),'=','tsLength_init;']);
    eval(['tsInit',num2str(c-1),'=','1;']);
    eval(['tsEnd',num2str(c-1),'=','tsLengths',num2str(c-1),';']);
    eval(['offset',num2str(c-1),'=','0;']);
end

validRes = 0;

counter = 1;
counterM=1;
counter0=1;
counter1=1;
detectedCB0 = 1;
detectedCB1 = 1;
testDetectingChange = [];
dimensionDetected =[];
p_vals = [];
h_vals = [];

confirmedDetections = [];
ClassDetected = [];

% timestamps projected onto marginal stream
tsInit_M = 1;
tsEnd_M = tsLength_init;
tsInit_0 = 1;
tsEnd_0 = tsLengths0;
tsInit_1 = 1;
tsEnd_1 = tsLengths1;

originalDetections = tsInit;

% change detection is iterated untill no change is detected (i.e. we reached the end of DataSet)
while(detected(counter) ~= 0)
    
    counter = counter + 1;
    % timestamps projected onto marginal stream
    fulldetected0 = 0;
    fulldetected1 = 0;
    fulldetectedM = 0;
    validRes = 0;
    
    %% Project data to subspace
    RSVMfull = f_1_generate_RSVM_data (ker, DataSet(1:end-1,:),label, DataSetReduced, lab, tsLengths(counter - 1), nF, ts);
    RSVMfull0 = RSVMfull(1:end-1,RSVMfull(end,:)==0);
    RSVMfull1 = RSVMfull(1:end-1,RSVMfull(end,:)==1);

    % the sum of DataSetReduced0 and DataSetReduced1 may not equal DataSetReduced except when counter = 1
    % so projection is carried out separately
    RSVMdatReduced = f_1_generate_RSVM_data (ker, DataSetReduced, lab, DataSetReduced ,lab, tsLengths(counter - 1), nF, ts);
    RSVMdatReduced = RSVMdatReduced(1:end-1,:);
    RSVMdatReduced0 = f_1_generate_RSVM_data (ker, DataSetReduced0,lab0, DataSetReduced, lab, tsLengths(counter - 1), nF, ts);
    RSVMdatReduced0= RSVMdatReduced0(1:end-1,:);
    RSVMdatReduced1 = f_1_generate_RSVM_data (ker, DataSetReduced1,lab1, DataSetReduced, lab, tsLengths(counter - 1), nF, ts);
    RSVMdatReduced1= RSVMdatReduced1(1:end-1,:);
    
    
    
    %% Execute detection
    % marginal detection
    [detectedM , testDetectingChangeInitM(counter) , Theta0M , dimensionDetectedM(counter)] = ...
        f_ICI_test_MultiDim(RSVMdatReduced , tsLengths(counter - 1) , params);
    % CB detection
    for c = 1:nc
        [dc, tmptestDetectingChangeInit , tmpTheta , tmpdimensionDetected] = ...
            f_ICI_test_MultiDim(eval(['RSVMdatReduced',num2str(c-1)]) , eval(['tsLengths',num2str(c-1),'(counter-1)']) , params);
        eval(['Theta0', num2str(c-1),'=','tmpTheta',';']);
        eval(['detectedCB', num2str(c-1),'=','dc',';']);
        eval(['testDetectingChangeInit', num2str(c-1),'(counter)','=','tmptestDetectingChangeInit',';']);
        eval(['dimensionDetected', num2str(c-1),'(counter)','=','tmpdimensionDetected',';']);
    end
    
    % find the true time stamp of detected change
    % record the class where the change took place
    if detectedM~=0
        fulldetectedM = f_position_on_marginal(RSVMfull(1:end-1,:), RSVMdatReduced(:,detectedM)', detected(counter-1));
    end
    
    if detectedCB0~=0
        fulldetected0 = f_position_on_marginal(RSVMfull(1:end-1,:),  RSVMdatReduced0(:,detectedCB0)', detected(counter-1));
    end
    
    
    if detectedCB1~=0
        fulldetected1 = f_position_on_marginal(RSVMfull(1:end-1,:),  RSVMdatReduced1(:,detectedCB1)', detected(counter-1));
    end
    
    tmpfull = [fulldetected0 fulldetected1 fulldetectedM];
    
    if any(tmpfull) % i.e. tmp is not a zero array i.e. 'change detected'
        % if a change is detected in both classes, record the earliest detection point
        tmpD = min(tmpfull(tmpfull ~=0));
        detected(counter) = tmpD;
        % class of which the change is detected % 1(class 0) or 2(class 1) or 3(marginal)
        tmpC = find(tmpfull== tmpD);
        originalDetections(counter) = detected(counter);
        
        if length(tmpC)==1  % if one detector reports the earliest detection
            Num_Alarmed_Detector = 1;
            subClassDetected = tmpC-1; % 0(class 0) or 1(class 1) or 2(marginal)
            ClassDetected(counter-1)= subClassDetected; % 0/1/2
        else   % if two detectors are alarmed at the same time stamp
            Num_Alarmed_Detector = 2;
            subClassDetected =  tmpC-1; % [0 2] or [1 2]
            C = subClassDetected(1:end-1); % 0 or 1
            ClassDetected(counter-1) = nc+C+1; % 3 or 4
            % 3 stands for class 0 + marginal; 4 stands for class 1 + margianl
        end
    else
        detected(counter) = 0;
    end
    
    %% Identify new Training set % run the refinement procedure on respective data stream
    if (detected(counter) > 0)
        if ismember(nc,subClassDetected)
            % 'a change is detected by marginal detector'
            [refinedM , testDetectingChange_tempM] = f_ICI_refine_test(RSVMdatReduced, detectedM, dimensionDetectedM(counter), tsLengths(counter - 1), params);
            
            % testDetectingChangeRefinementM(counter) = testDetectingChange_temp(max([length(testDetectingChange_tempM) - 1 , 1]));
            
            if params.MinimumTS_Size > 0
                % update detection within the original DataSet
                tsLengths_M(counter) = ceil((detectedM - refinedM) / params.windowWidth) * params.windowWidth;
                tsLengths_M(counter) = max([tsLengths_M(counter), params.MinimumTS_Size]);
            else
                % in case no minimum training set is required, we expect no configuration is required. Then, no need to take
                % a training set proportional to the window.
                tsLengths_M(counter) = detectedM - refinedM;
            end
            
            % prende l'inizio del TS alla refinement
            % remove offset, the size of the possibly added TS
            tsInit_M(counter) = DataSetStartIndex + refinedM - offset;
            % prende almeno params.MinimumTS_Size a partire da  tsInit
            tsEnd_M(counter) = min([tsInit_M(counter) + tsLengths_M(counter) , size(DataSet , 2)]);
            
            if length(subClassDetected)>=2
                % Record name for later comparison
                tsInit_Full = tsInit_M(counter);
                tsEnd_Full = tsEnd_M(counter);
                tsLengths_Full = tsLengths_M(counter);
            else
                % only 1 detector so tsInit tsEnd tsLengths can be fixed
                % without extra effort
                tsInit(counter) = tsInit_M(counter);
                tsEnd(counter) = tsEnd_M(counter);
                tsLengths(counter) = tsLengths_M(counter);
            end
        end
        
        if ismember(nc-1,subClassDetected)
            [refined1 , testDetectingChange_temp1] = f_ICI_refine_test(RSVMdatReduced1, detectedCB1, dimensionDetected1(counter), tsLengths1(counter - 1), params);
            % testDetectingChangeRefinement1(counter) = testDetectingChange_temp(max([length(testDetectingChange_temp1) - 1 , 1]));
            
            if params.MinimumTS_Size > 0
                tsLengths1(counter) = ceil((detectedCB1 - refined1) / params.windowWidth) * params.windowWidth;
                % require a minimum training set length
                tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
            else
                % in case no minimum training set is required, we expect no configuration is required. Then, no need to take
                % a training set proportional to the window.
                tsLengths1(counter) = detectedCB1 - refined1;
            end
            
            tsInit1(counter) = DataSetStartIndex1 + refined1 - offset1;
            tsEnd1(counter) = min([tsInit1(counter) + tsLengths1(counter) , size(DataSet1 , 2)]);
            
            % find marginal tsInit & tsEnd
            tsInit_1(counter) = f_position_on_marginal(DataSet, DataSet1(:,tsInit1(counter))',DataSetStartIndex1);
            % [~,tsInit_1(counter)] = ismember( DataSet1(:,tsInit1(counter))',DataSet','rows');
            tsEnd_1(counter) = f_position_on_marginal(DataSet, DataSet1(:,tsEnd1(counter))', DataSetStartIndex1);
            % [~,tsEnd_1(counter)] = ismember( DataSet1(:,tsEnd1(counter))',DataSet','rows');
            tsLengths_1(counter) = tsEnd_1(counter)-tsInit_1(counter);
            
            
            if length(subClassDetected)>=2
                K = [tsInit_Full tsInit_1(counter)];
                % if tsInit_1 = tsInit_M
                % does not matter which detector's result we follow
                % take the earliest tsInit
                tmpInit = find(K == min(K));
                tsInit(counter) = min(K);
                tsLengths(counter) = max([(tsEnd_Full - tsInit(counter)), params.MinimumTS_Size]);
                tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
            else
                tsInit(counter) = tsInit_1(counter);
                tsEnd(counter) = tsEnd_1(counter);
                tsLengths(counter) = tsLengths_1(counter);
            end
            
            
            
        elseif  ismember(nc-2,subClassDetected)
            
            
            % testDetectingChangeInit0(counter) = testDetectingChangeInit0(counter) ;
            [refined0 , testDetectingChange_temp0] = f_ICI_refine_test(RSVMdatReduced0, detectedCB0, dimensionDetected0(counter), tsLengths0(counter - 1), params);
            % testDetectingChangeRefinement(counter) = testDetectingChange_temp(max([length(testDetectingChange_temp) - 1 , 1]));
            
            
            if params.MinimumTS_Size > 0
                tsLengths0(counter) = ceil((detectedCB0 - refined0) / params.windowWidth) * params.windowWidth;
                % require a minimum training set length
                tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
            else
                % in case no minimum training set is required, we expect no configuration is required. Then, no need to take
                % a training set proportional to the window.
                tsLengths0(counter) = detectedCB0 - refined0;
            end
            
            tsInit0(counter) = DataSetStartIndex0 + refined0 - offset0;
            tsEnd0(counter) = min([tsInit0(counter) + tsLengths0(counter) , size(DataSet0 , 2)]);
            
            % find marginal tsInit & tsEnd
            tsInit_0(counter) = f_position_on_marginal(DataSet, DataSet0(:,tsInit0(counter))', DataSetStartIndex0);
            % [~,tsInit_1(counter)] = ismember( DataSet1(:,tsInit0(counter))',DataSet','rows');
            tsEnd_0(counter) = f_position_on_marginal(DataSet, DataSet0(:,tsEnd0(counter))', DataSetStartIndex0);
            % [~,tsEnd_1(counter)] = ismember( DataSet1(:,tsEnd0(counter))',DataSet','rows');
            tsLengths_0(counter) = tsEnd_0(counter)-tsInit_0(counter);
            
            
            if length(subClassDetected)>=2
                % Record name for later comparison
                K = [tsInit_Full tsInit_0(counter)];
                % if tsInit_1 = tsInit_M
                % does not matter which class we choose
                % if not, take the earliest tsInit
                tmpInit = find(K == min(K));
                tsInit(counter) = min(K);
                tsLengths(counter) = max([(tsEnd_Full - tsInit(counter)), params.MinimumTS_Size]);
                tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
            else
                tsInit(counter) = tsInit_0(counter);
                tsEnd(counter) = tsEnd_0(counter);
                tsLengths(counter) = tsLengths_0(counter);
            end
            
        end
        
        %% if no validation is required, then
        if params.do_stop_first_detection && params.do_validate_changes == 0
            confirmedDetections = [originalDetections(counter)];
            return; % the first detection has been found. Stop the CDT as no validation is required
        end
        
        %% if validation is required, hierarchical procedure, run batch hypothesis test
        % partition DataSet to perform hyopothesis test
        
        if  ismember(nc,subClassDetected)
            if (tsInit(counter - 1) == 1)
                oldTS_Init = 1; % primo sample del DataSet, parte da quello
            else
                oldTS_Init = tsInit(counter - 1) + 1; % non siamo al primo dataset, parte da un sample dopo la detectin precedente
            end
            
            if (strcmpi(params.HT_Partition , 'TrainingSet'))
                oldTS_End = tsEnd(counter - 1);
            end
            
            if (strcmpi(params.HT_Partition , 'DataSet'))
                oldTS_End = tsInit(counter);
            end
            
            newTS_Init =  tsInit(counter) + 1;
            newTS_End =  tsEnd(counter);
            oldTS = RSVMfull(1:end-1 , oldTS_Init : oldTS_End);
            newTS = RSVMfull(1:end-1 , newTS_Init : newTS_End);
            
            
            if (length(newTS) >= params.MinimumTS_Size)
                if(strcmpi(params.HT_Name , 'ztest'))
                    % run z test on the sample means
                    m1 = mean(oldTS);
                    s1 = var(oldTS)/ length(oldTS);
                    
                    m2 = mean(newTS);
                    s2 = var(newTS) / length(newTS);
                    
                    [h_testM , p_valM] = ztest(m1 - m2 , 0 , sqrt(s1 + s2) , params.alpha);
                end
                
                if (strcmpi(params.HT_Name , 'KolmogorovSmirnov'))
                    [h_testM , p_valM] = kstest2(oldTS , newTS , params.alpha);
                end
                
                if strcmpi(params.HT_Name, 'Proportions')
                    [h_testM, p_valM] = validateChanges_err(RSVMfull(1:end-1,:) , oldTS_Init, oldTS_End, newTS_Init, newTS_End, params.alpha);
                end
                
                if (strcmpi(params.HT_Name , 'Multivariate') || strcmpi(params.HT_Name , 'Hotelling') )
                    [h_testM, p_valM] = validateChanges_Data(RSVMfull(1:end-1,:), testDetectingChangeInitM(counter), oldTS_Init, oldTS_End, newTS_Init, newTS_End, params);
                end
                
                h_vals(counter) = h_testM;
                p_vals(counter) = p_valM;
            else
                h_testM = 1;
                h_vals(counter) = NaN;
                p_vals(counter) = NaN;
            end
            if h_testM ==1
                validRes = 1;
            end
        end
        
        if ismember(nc-1,subClassDetected)
            % 'change detected in C1'
            if (tsInit1(counter - 1) == 1)
                oldTS_Init = 1; % primo sample del DataSet, parte da quello
            else
                oldTS_Init= tsInit1(counter - 1) + 1; % non siamo al primo dataset, parte da un sample dopo la detectin precedente
            end
            
            if (strcmpi(params.HT_Partition , 'TrainingSet'))
                oldTS_End = tsEnd1(counter - 1);
            end
            
            if (strcmpi(params.HT_Partition , 'DataSet'))
                oldTS_End = tsInit1(counter);
            end
            
            newTS_Init = tsInit1(counter) + 1;
            newTS_End =  tsEnd1(counter);
            
            oldTS = RSVMfull1(: , oldTS_Init : oldTS_End);
            newTS = RSVMfull1(: , newTS_Init : newTS_End);
            
            if (length(newTS) >= params.MinimumTS_Size)
                
                if(strcmpi(params.HT_Name , 'ztest'))
                    % run z test on the sample means
                    m1 = mean(oldTS);
                    s1 = var(oldTS)/ length(oldTS);
                    
                    m2 = mean(newTS);
                    s2 = var(newTS) / length(newTS);
                    
                    [h_test1 , p_val1] = ztest(m1 - m2 , 0 , sqrt(s1 + s2) , params.alpha);
                end
                
                if (strcmpi(params.HT_Name , 'KolmogorovSmirnov'))
                    [h_test1 , p_val1] = kstest2(oldTS , newTS , params.alpha);
                end
                
                if strcmpi(params.HT_Name, 'Proportions')
                    [h_test1, p_val1] = validateChanges_err(RSVMfull1 , oldTS_Init, oldTS_End, newTS_Init, newTS_End, params.alpha);
                end
                
                if (strcmpi(params.HT_Name , 'Multivariate') || strcmpi(params.HT_Name , 'Hotelling') )
                    [h_test1, p_val1] = validateChanges_Data(RSVMfull1, testDetectingChangeInit1(counter), oldTS_Init, oldTS_End, newTS_Init, newTS_End, params);
                end
                
                h_vals(counter) = h_test1;
                p_vals(counter) = p_val1;
            else
                h_test1 = 1;
                h_vals(counter) = NaN;
                p_vals(counter) = NaN;
            end
            
            if h_test1 ==1
                validRes = 1;
            end
            
        elseif   ismember(nc-2,subClassDetected)
            % 'change detected in C0'
            if (tsInit0(counter - 1) == 1)
                oldTS_Init = 1; % primo sample del DataSet, parte da quello
            else
                oldTS_Init= tsInit0(counter - 1) + 1; % non siamo al primo dataset, parte da un sample dopo la detectin precedente
            end
            
            if (strcmpi(params.HT_Partition , 'TrainingSet'))
                oldTS_End = tsEnd0(counter - 1);
            end
            
            if (strcmpi(params.HT_Partition , 'DataSet'))
                oldTS_End = tsInit0(counter);
            end
            
            newTS_Init = tsInit0(counter) + 1;
            newTS_End =  tsEnd0(counter);
            
            oldTS = RSVMfull0(: , oldTS_Init : oldTS_End);
            newTS = RSVMfull0(: , newTS_Init : newTS_End);
            
            if (length(newTS) >= params.MinimumTS_Size)
                
                if(strcmpi(params.HT_Name , 'ztest'))
                    % run z test on the sample means
                    m1 = mean(oldTS);
                    s1 = var(oldTS)/ length(oldTS);
                    
                    m2 = mean(newTS);
                    s2 = var(newTS) / length(newTS);
                    
                    [h_test0 , p_val0] = ztest(m1 - m2 , 0 , sqrt(s1 + s2) , params.alpha);
                end
                
                if (strcmpi(params.HT_Name , 'KolmogorovSmirnov'))
                    [h_test0 , p_val0] = kstest2(oldTS , newTS , params.alpha);
                end
                
                if strcmpi(params.HT_Name, 'Proportions')
                    [h_test0, p_val0] = validateChanges_err(RSVMfull0 , oldTS_Init, oldTS_End, newTS_Init, newTS_End, params.alpha);
                end
                testDetectingChangeInit0(counter)
                
                if (strcmpi(params.HT_Name , 'Multivariate') || strcmpi(params.HT_Name , 'Hotelling') )
                    [h_test0, p_val0] = validateChanges_Data(RSVMfull0, testDetectingChangeInit0(counter), oldTS_Init, oldTS_End, newTS_Init, newTS_End, params);
                end
                
                h_vals(counter) = h_test0;
                p_vals(counter) = p_val0;
            else
                h_test0 = 1;
                h_vals(counter) = NaN;
                p_vals(counter) = NaN;
            end
            if h_test0 ==1
                validRes = 1;
            end
            
        end
        
        %% Check Validation Results
        
        if (validRes==1)
            confirmedDetections = [confirmedDetections , originalDetections(counter)];
        end
        %% The following is presented in the table of the construction of re-training sets
        
        if (counter == 2)
            TS = DataSet(: , tsInit(counter-1) : tsEnd(counter-1));
            % changed TS1 TS0, results changed slightly
            %TS1 = TS(:,TS(end,:)==1);  % initial CL0
            %TS0 = TS(:,TS(end,:)==0);  % initial CL1
            TS1 = DataSet1(: , tsInit1(counter-1) : tsEnd1(counter-1));  % initial CL1
            TS0 = DataSet0(: , tsInit0(counter-1) : tsEnd0(counter-1));  % initial CL0
        end
        
        % new training set
        
        tmpTS = DataSet(: , tsInit(counter): tsEnd(counter));
        tmp_tmpTS0 = tmpTS(:,tmpTS(end,:)==0);
        tmp_tmpTS1 = tmpTS(:,tmpTS(end,:)==1);
        % 2020.2.3
        tmpTS0 = tmp_tmpTS0;
        tmpTS1 = tmp_tmpTS1;
        %tmpTS0 = tmp_tmpTS0 (:,1:(floor(size(tmp_tmpTS0,2)/params.windowWidth) * params.windowWidth));
        %tmpTS1 = tmp_tmpTS1 (:,1:(floor(size(tmp_tmpTS1,2)/params.windowWidth) * params.windowWidth));
        
        
        if ((params.do_validate_changes == 0)||size(tmpTS0,2) ==0 || size(tmpTS1,2) ==0)
            detected(counter) = 0;
        else
            
            switch Num_Alarmed_Detector
               
                case 2  % Num_Alarmed_Detector
%% two detectors raise alarms                     
                     
                    'CB + marginal based detector'
                    
                    switch ClassDetected(counter-1)
                        
                        case nc+0+1  %ClassDetected(counter-1)
                            
                            % CB0 + marginal based detector
                            
                            if h_testM==1 && h_test0 ==1
                                 'both confirmed M0'
                                % cell(1,1)
                                % M C0 retrained on new set
                                % C1 combine
                                % 2 detectors, do need the following step
                                tsInit0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,1)', DataSetStartIndex0);
                                DataSetStartIndex0 = tsInit0(counter);
                                TmpSetReduced0 = DataSet0(: , DataSetStartIndex0 + 1 : end);
                                FDataSetReduced0 = TmpSetReduced0;
                                
                                tsLengths0(counter) = ceil(size(tmpTS0,2) / params.windowWidth) * params.windowWidth;
                                tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                tsEnd0(counter) = min([tsInit0(counter) + tsLengths0(counter) , size(DataSet0, 2)]);
                                
                                TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                offset0 = 0;
                                
                                if isempty(tmpTS1)
                                    % nothing to combine
                                    % keep everything the way it is and continue testing
                                    % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                    tsLengths1(counter) = tsLengths1(counter-1);
                                    tsInit1(counter) = tsInit1(counter-1);
                                    tsEnd1(counter)= tsEnd1(counter-1);
                                else
                                    tmpDataSetStartIndex1 = f_position_on_marginal(DataSet1, tmpTS1(:,end)', DataSetStartIndex1);
                                    TmpSetReduced1 = DataSet1(: , tmpDataSetStartIndex1 + 1 : end);
                                    FDataSetReduced1 = [TS1, tmpTS1, TmpSetReduced1];
                                    
                                    tsLengths1(counter) = ceil(size([TS1, tmpTS1],2) / params.windowWidth) * params.windowWidth;
                                    tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                    
                                    TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                    offset1 = size(TS1, 2);
                                    
                                    tsInit1(counter) = tsInit1(counter-1);
                                    % combined set naturally satistifies minTSsize
                                    if tsInit1(counter)==1
                                        tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter)-1 ;
                                    else
                                        tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter);
                                    end
                                    DataSetStartIndex1 =  f_position_on_marginal(DataSet1, TS1(:,end)', DataSetStartIndex1);
                                end
                                
                                
                                DataSetStartIndex = tsInit(counter);
                                TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                FDataSetReduced = TmpSetReduced;
                                
                                tsLengths(counter) = ceil(size(tmpTS,2) / params.windowWidth) * params.windowWidth;
                                tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
                                tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
                                
                                TS = FDataSetReduced(:,1:min(size(FDataSetReduced,2),tsLengths(counter)));
                                offset = 0;
                                
                            elseif  h_testM==0 && h_test0 ==0
                                'both not confirmed M0'
                                % cell(2,2)
                                % M C0  not retrained
                                % C1 combine
                                
                                
                                % C0 M no retraining
                                % C1 combine
                                
                                % two detectors took the earlisest point which we do not know M or C0; makes differences
                                % so we do need
                                tsEnd0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                DataSetStartIndex0 = tsEnd0(counter);
                                TmpSetReduced0 = DataSet0(: , DataSetStartIndex0 + 1 : end);
                                FDataSetReduced0 = [TS0, TmpSetReduced0];
                                % TS0 not updated
                                offset0 = size(TS0, 2);
                                
                                tsInit0(counter) =  tsInit0(counter-1);
                                tsEnd0(counter) = tsEnd0(counter-1);
                                tsLengths0(counter) = tsLengths0(counter-1);
                                
                                
                                if isempty(tmpTS1)
                                    % nothing to combine
                                    % keep everything the way it is and continue testing
                                    % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                    tsLengths1(counter) = tsLengths1(counter-1);
                                    tsInit1(counter) = tsInit1(counter-1);
                                    tsEnd1(counter)= tsEnd1(counter-1);
                                else
                                    tmpDataSetStartIndex1 = f_position_on_marginal(DataSet1, tmpTS1(:,end)', DataSetStartIndex1);
                                    TmpSetReduced1 = DataSet1(: , tmpDataSetStartIndex1 + 1 : end);
                                    FDataSetReduced1 = [TS1, tmpTS1, TmpSetReduced1];
                                    
                                    tsLengths1(counter) = ceil(size([TS1, tmpTS1],2) / params.windowWidth) * params.windowWidth;
                                    tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                    
                                    TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                    offset1 = size(TS1, 2);
                                    
                                    tsInit1(counter) = tsInit1(counter-1);
                                    % combined set naturally satistifies minTSsize
                                    if tsInit1(counter)==1
                                        tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter)-1 ;
                                    else
                                        tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter);
                                    end
                                    DataSetStartIndex1 =  f_position_on_marginal(DataSet1, TS1(:,end)', DataSetStartIndex1);
                                end
                                
                                
                                DataSetStartIndex = tsEnd(counter);
                                TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                FDataSetReduced = [TS, TmpSetReduced];
                                % TS not updated
                                offset = size(TS, 2);
                                
                                tsLengths(counter) = tsLengths(counter-1);
                                tsInit(counter) = tsInit(counter-1);
                                tsEnd(counter) = tsEnd(counter-1);
                                
                            elseif h_testM==1 && h_test0 ==0
                                % 'one confirmed - marginal'
                                % cell(2,1)
                                
                                % M retrain on new set
                                % C0 no retraining
                                % C1 combine
                                
                                % SCHEME 2 !!!!!
                                % M retrain on new set
                                % C0 retrain on new set
                                % C1 retrain on new set
                                
                                    if isempty(tmpTS1)
                                        % nothing to retrain on 
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                        tsLengths1(counter) = tsLengths1(counter-1);
                                        tsInit1(counter) = tsInit1(counter-1);
                                        tsEnd1(counter)= tsEnd1(counter-1);
                                    else
                                        tsInit1(counter) = f_position_on_marginal(DataSet1, tmpTS1(:,1)', DataSetStartIndex1);
                                        tsEnd1(counter) = f_position_on_marginal(DataSet1, tmpTS1(:,end)', DataSetStartIndex1);
                                        
                                        DataSetStartIndex1 = tsInit1(counter);
                                        TmpSetReduced1 = DataSet1(: , DataSetStartIndex1 + 1 : end);
                                        FDataSetReduced1 =  TmpSetReduced1;
                                        
                                        tsLengths1(counter) = ceil(size([tmpTS1],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                        
                                        TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                        offset1 =0;
                                    end
                                    
                                    
                                    if isempty(tmpTS0)
                                        % nothing to combine
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex0 TmpSetReduced0 offset0 TS0 FDataSetReduced0 all remain the same as the previous iteration
                                        tsLengths0(counter) = tsLengths0(counter-1);
                                        tsInit0(counter) = tsInit0(counter-1);
                                        tsEnd0(counter)= tsEnd0(counter-1);
                                    else
                                        tsInit0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,1)', DataSetStartIndex0);
                                        tsEnd0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                        
                                        DataSetStartIndex0 = tsInit0(counter);
                                        TmpSetReduced0 = DataSet0(: , DataSetStartIndex0 + 1 : end);
                                        FDataSetReduced0 =  TmpSetReduced0;
                                        
                                        tsLengths0(counter) = ceil(size([tmpTS0],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                        
                                        TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                        offset0 =0;
                                    end
                                    
                                    DataSetStartIndex = tsInit(counter);
                                    TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                    FDataSetReduced = TmpSetReduced;
                                    
                                    tsLengths(counter) = ceil(size(tmpTS,2) / params.windowWidth) * params.windowWidth;
                                    tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
                                    tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
                                    
                                    TS = FDataSetReduced(:,1:min(size(FDataSetReduced,2),tsLengths(counter)));
                                    offset = 0;
                                
                                
                            elseif h_testM==0 && h_test0 ==1
                                
                                'one confirmed - class0'
                                % cell(1,2)
                                % C0 M retrain
                                % C1 combine
                                
                                % 2 detectors, do need the following step
                                tsInit0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,1)', DataSetStartIndex0);
                                DataSetStartIndex0 = tsInit0(counter);
                                TmpSetReduced0 = DataSet0(: , DataSetStartIndex0 + 1 : end);
                                FDataSetReduced0 = TmpSetReduced0;
                                
                                tsLengths0(counter) = ceil(size(tmpTS0,2) / params.windowWidth) * params.windowWidth;
                                tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                tsEnd0(counter) = min([tsInit0(counter) + tsLengths0(counter) , size(DataSet0, 2)]);
                                
                                TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                offset0 = 0;
                                
                                if isempty(tmpTS1)
                                    % nothing to combine
                                    % keep everything the way it is and continue testing
                                    % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                    tsLengths1(counter) = tsLengths1(counter-1);
                                    tsInit1(counter) = tsInit1(counter-1);
                                    tsEnd1(counter)= tsEnd1(counter-1);
                                else
                                    tmpDataSetStartIndex1 = f_position_on_marginal(DataSet1, tmpTS1(:,end)', DataSetStartIndex1);
                                    TmpSetReduced1 = DataSet1(: , tmpDataSetStartIndex1 + 1 : end);
                                    FDataSetReduced1 = [TS1, tmpTS1, TmpSetReduced1];
                                    
                                    tsLengths1(counter) = ceil(size([TS1, tmpTS1],2) / params.windowWidth) * params.windowWidth;
                                    tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                    
                                    TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                    offset1 = size(TS1, 2);
                                    
                                    tsInit1(counter) = tsInit1(counter-1);
                                    % combined set naturally satistifies minTSsize
                                    if tsInit1(counter)==1
                                        tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter)-1 ;
                                    else
                                        tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter);
                                    end
                                    DataSetStartIndex1 =  f_position_on_marginal(DataSet1, TS1(:,end)', DataSetStartIndex1);
                                end
                                
                                
                                DataSetStartIndex = tsInit(counter);
                                TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                FDataSetReduced = TmpSetReduced;
                                
                                tsLengths(counter) = ceil(size(tmpTS,2) / params.windowWidth) * params.windowWidth;
                                tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
                                tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
                                
                                TS = FDataSetReduced(:,1:min(size(FDataSetReduced,2),tsLengths(counter)));
                                offset = 0;
                            end
                            
                            
                        case nc+0+2   %ClassDetected(counter-1)
                            % CB1 + marginal based detector
                            
                            if h_testM==1 && h_test1 ==1
                                'both confirmed M1'
                                
                                % cell(1,1)
                                % M C1  retrained on new set
                                % C0 combine
                                % 2 detectors, do need the following step
                                tsInit1(counter) = f_position_on_marginal(DataSet1, tmpTS1(:,1)', DataSetStartIndex1);
                                DataSetStartIndex1 = tsInit1(counter);
                                TmpSetReduced1 = DataSet1(: , DataSetStartIndex1 + 1 : end);
                                FDataSetReduced1 = TmpSetReduced1;
                                
                                tsLengths1(counter) = ceil(size(tmpTS1,2) / params.windowWidth) * params.windowWidth;
                                tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                tsEnd1(counter) = min([tsInit1(counter) + tsLengths1(counter) , size(DataSet1 , 2)]);
                                
                                TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                offset1 = 0;
                                
                                if isempty(tmpTS0)
                                    % nothing to combine
                                    % keep everything the way it is and continue testing
                                    % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                    tsLengths0(counter) = tsLengths0(counter-1);
                                    tsInit0(counter) = tsInit0(counter-1);
                                    tsEnd0(counter)= tsEnd0(counter-1);
                                else
                                    tmpDataSetStartIndex0 = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                    TmpSetReduced0 = DataSet0(: , tmpDataSetStartIndex0 + 1 : end);
                                    FDataSetReduced0 = [TS0, tmpTS0, TmpSetReduced0];
                                    
                                    tsLengths0(counter) = ceil(size([TS0, tmpTS0],2) / params.windowWidth) * params.windowWidth;
                                    tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                    
                                    TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                    offset0 = size(TS0, 2);
                                    
                                    tsInit0(counter) = tsInit0(counter-1);
                                    % combined set naturally satistifies minTSsize
                                    if tsInit0(counter)==1
                                        tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter)-1 ;
                                    else
                                        tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter);
                                    end
                                    DataSetStartIndex0 =  f_position_on_marginal(DataSet0, TS0(:,end)', DataSetStartIndex0);
                                end
                                
                                
                                DataSetStartIndex = tsInit(counter);
                                TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                FDataSetReduced = TmpSetReduced;
                                
                                tsLengths(counter) = ceil(size(tmpTS,2) / params.windowWidth) * params.windowWidth;
                                tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
                                tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
                                
                                TS = FDataSetReduced(:,1:min(size(FDataSetReduced,2),tsLengths(counter)));
                                offset = 0;
                            elseif  h_testM==0 && h_test1 ==0
                                'both not confirmed M1'
                                % cell(2,2)
                                
                                % M C1  no retraining
                                % C0 combine
                                % two detectors took the earlisest point which we do not know M or C1; makes differences
                                % so we do need
                                tsEnd1(counter) = f_position_on_marginal(DataSet1, tmpTS1(:,end)', DataSetStartIndex1);
                                DataSetStartIndex1 = tsEnd1(counter);
                                TmpSetReduced1 = DataSet1(: , DataSetStartIndex1 + 1 : end);
                                FDataSetReduced1 = [TS1, TmpSetReduced1];
                                % TS1 not updated
                                offset1 = size(TS1, 2);
                                
                                tsInit1(counter) =  tsInit1(counter-1);
                                tsEnd1(counter) = tsEnd1(counter-1);
                                tsLengths1(counter) = tsLengths1(counter-1);
                                
                                
                                if isempty(tmpTS0)
                                    % nothing to combine
                                    % keep everything the way it is and continue testing
                                    % DataSetStartIndex0 TmpSetReduced0 offset0 TS0 FDataSetReduced0 all remain the same as the previous iteration
                                    tsLengths0(counter) = tsLengths0(counter-1);
                                    tsInit0(counter) = tsInit0(counter-1);
                                    tsEnd0(counter)= tsEnd0(counter-1);
                                else
                                    tmpDataSetStartIndex0 = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                    TmpSetReduced0 = DataSet0(: , tmpDataSetStartIndex0 + 1 : end);
                                    FDataSetReduced0 = [TS0, tmpTS0, TmpSetReduced0];
                                    
                                    tsLengths0(counter) = ceil(size([TS0, tmpTS0],2) / params.windowWidth) * params.windowWidth;
                                    tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                    
                                    TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                    offset0 = size(TS0, 2);
                                    
                                    tsInit0(counter) = tsInit0(counter-1);
                                    % combined set naturally satistifies minTSsize
                                    if tsInit0(counter)==1
                                        tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter)-1 ;
                                    else
                                        tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter);
                                    end
                                    DataSetStartIndex0 =  f_position_on_marginal(DataSet0, TS0(:,end)', DataSetStartIndex0);
                                end
                                
                                
                                DataSetStartIndex = tsEnd(counter);
                                TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                FDataSetReduced = [TS, TmpSetReduced];
                                % TS not updated
                                offset = size(TS, 2);
                                
                                tsLengths(counter) = tsLengths(counter-1);
                                tsInit(counter) = tsInit(counter-1);
                                tsEnd(counter) = tsEnd(counter-1);
                                
                            elseif h_testM==1 && h_test1 ==0
                                'marginal - confirmed; class1 - not confirmed'
                                % cell(2,1)
                                
                                % M retrain on new set
                                % C1 no retraining
                                % C0 combine% SCHEME 2 !!!!!
                                % M retrain on new set
                                % C0 retrain on new set
                                % C1 retrain on new set
                                
                                    if isempty(tmpTS1)
                                        % nothing to retrain on 
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                        tsLengths1(counter) = tsLengths1(counter-1);
                                        tsInit1(counter) = tsInit1(counter-1);
                                        tsEnd1(counter)= tsEnd1(counter-1);
                                    else
                                        tsInit1(counter) = f_position_on_marginal(DataSet1, tmpTS1(:,1)', DataSetStartIndex1);
                                        tsEnd1(counter) = f_position_on_marginal(DataSet1, tmpTS1(:,end)', DataSetStartIndex1);
                                        
                                        DataSetStartIndex1 = tsInit1(counter);
                                        TmpSetReduced1 = DataSet1(: , DataSetStartIndex1 + 1 : end);
                                        FDataSetReduced1 =  TmpSetReduced1;
                                        
                                        tsLengths1(counter) = ceil(size([tmpTS1],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                        
                                        TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                        offset1 =0;
                                    end
                                    
                                    
                                    if isempty(tmpTS0)
                                        % nothing to combine
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex0 TmpSetReduced0 offset0 TS0 FDataSetReduced0 all remain the same as the previous iteration
                                        tsLengths0(counter) = tsLengths0(counter-1);
                                        tsInit0(counter) = tsInit0(counter-1);
                                        tsEnd0(counter)= tsEnd0(counter-1);
                                    else
                                        tsInit0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,1)', DataSetStartIndex0);
                                        tsEnd0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                        
                                        DataSetStartIndex0 = tsInit0(counter);
                                        TmpSetReduced0 = DataSet0(: , DataSetStartIndex0 + 1 : end);
                                        FDataSetReduced0 =  TmpSetReduced0;
                                        
                                        tsLengths0(counter) = ceil(size([tmpTS0],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                        
                                        TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                        offset0 =0;
                                    end
                                    
                                    DataSetStartIndex = tsInit(counter);
                                    TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                    FDataSetReduced = TmpSetReduced;
                                    
                                    tsLengths(counter) = ceil(size(tmpTS,2) / params.windowWidth) * params.windowWidth;
                                    tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
                                    tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
                                    
                                    TS = FDataSetReduced(:,1:min(size(FDataSetReduced,2),tsLengths(counter)));
                                    offset = 0;
                                
                                
                            elseif h_testM==0 && h_test1 ==1
                                'marginal - not confirmed; class1 - confirmed'
                                % cell(1,2)
                                
                                % M C1 retrain on new set
                                % C0 combine
                                
                                % 2 detectors, do need the following step
                                tsInit1(counter) = f_position_on_marginal(DataSet1, tmpTS1(:,1)', DataSetStartIndex1);
                                DataSetStartIndex1 = tsInit1(counter);
                                TmpSetReduced1 = DataSet1(: , DataSetStartIndex1 + 1 : end);
                                FDataSetReduced1 = TmpSetReduced1;
                                
                                tsLengths1(counter) = ceil(size(tmpTS1,2) / params.windowWidth) * params.windowWidth;
                                tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                tsEnd1(counter) = min([tsInit1(counter) + tsLengths1(counter) , size(DataSet1 , 2)]);
                                
                                TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                offset1 = 0;
                                
                                if isempty(tmpTS0)
                                    % nothing to combine
                                    % keep everything the way it is and continue testing
                                    % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                    tsLengths0(counter) = tsLengths0(counter-1);
                                    tsInit0(counter) = tsInit0(counter-1);
                                    tsEnd0(counter)= tsEnd0(counter-1);
                                else
                                    tmpDataSetStartIndex0 = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                    TmpSetReduced0 = DataSet0(: , tmpDataSetStartIndex0 + 1 : end);
                                    FDataSetReduced0 = [TS0, tmpTS0, TmpSetReduced0];
                                    
                                    tsLengths0(counter) = ceil(size([TS0, tmpTS0],2) / params.windowWidth) * params.windowWidth;
                                    tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                    
                                    TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                    offset0 = size(TS0, 2);
                                    
                                    tsInit0(counter) = tsInit0(counter-1);
                                    % combined set naturally satistifies minTSsize
                                    if tsInit0(counter)==1
                                        tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter)-1 ;
                                    else
                                        tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter);
                                    end
                                    DataSetStartIndex0 =  f_position_on_marginal(DataSet0, TS0(:,end)', DataSetStartIndex0);
                                end
                                
                                
                                DataSetStartIndex = tsInit(counter);
                                TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                FDataSetReduced = TmpSetReduced;
                                
                                tsLengths(counter) = ceil(size(tmpTS,2) / params.windowWidth) * params.windowWidth;
                                tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
                                tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
                                
                                TS = FDataSetReduced(:,1:min(size(FDataSetReduced,2),tsLengths(counter)));
                                offset = 0;
                                
                            end
                    end
                    
%% only one detectorraises an alarm                    
                case 1  % Num_Alarmed_Detector
                    
                    switch ClassDetected(counter-1)
                        case 0
                            % only examine h_test0
                            
                            switch  h_test0
                                case 1
                                    'drift confirmed in single C0 detector'
                                    % cell(1,3)
                                    
                                    % preparation for next round for marginal
                                    
                                    % C0 M retrain on newest
                                    % C1 combine
                                    
                                    % one detector only should not make any differences changed tmpTS = init:end without init+1 
                                    % so we do not need tsInit0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,1)', DataSetStartIndex0);
                                    DataSetStartIndex0 = tsInit0(counter);
                                    TmpSetReduced0 = DataSet0(: , DataSetStartIndex0 + 1 : end);
                                    FDataSetReduced0 = TmpSetReduced0;
                                    
                                    tsLengths0(counter) = ceil(size(tmpTS0,2) / params.windowWidth) * params.windowWidth;
                                    tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                    tsEnd0(counter) = min([tsInit0(counter) + tsLengths0(counter) , size(DataSet0, 2)]);
                                    
                                    TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                    offset0 = 0;
                                    
                                    if isempty(tmpTS1)
                                        % nothing to combine
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                        tsLengths1(counter) = tsLengths1(counter-1);
                                        tsInit1(counter) = tsInit1(counter-1);
                                        tsEnd1(counter)= tsEnd1(counter-1);
                                    else
                                        tmpDataSetStartIndex1 = f_position_on_marginal(DataSet1, tmpTS1(:,end)', DataSetStartIndex1);
                                        TmpSetReduced1 = DataSet1(: , tmpDataSetStartIndex1 + 1 : end);
                                        FDataSetReduced1 = [TS1, tmpTS1, TmpSetReduced1];
                                        tsLengths1(counter) = ceil(size([TS1, tmpTS1],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                        
                                        TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                        offset1 = size(TS1, 2);
                                        
                                        tsInit1(counter) = tsInit1(counter-1);
                                        % combined set naturally satistifies minTSsize
                                        if tsInit1(counter)==1
                                            tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter)-1 ;
                                        else
                                            tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter);
                                        end
                                        DataSetStartIndex1 =  f_position_on_marginal(DataSet1, TS1(:,end)', DataSetStartIndex1);
                                    end
                                    
                                    
                                    DataSetStartIndex = tsInit(counter);
                                    TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                    FDataSetReduced = TmpSetReduced;
                                    
                                    tsLengths(counter) = ceil(size(tmpTS,2) / params.windowWidth) * params.windowWidth;
                                    tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
                                    tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
                                    
                                    TS =  FDataSetReduced(:,1:min(size(FDataSetReduced,2),tsLengths(counter)));
                                    offset = 0;
                                case 0
                                    'drift not confirmed in single C0 detector'
                                    % cell(2,3)
                                    % M combine 
                                    % C0 no retraining
                                    % C1 combine
                                    
                                    % one detector only should not make any differences changed tmpTS = init:end without init+1 
                                    % so we do not need tsEnd0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                   
                                    DataSetStartIndex0 = tsEnd0(counter);
                                    TmpSetReduced0 = DataSet0(: , DataSetStartIndex0 + 1 : end);
                                    FDataSetReduced0 = [TS0, TmpSetReduced0];
                                    % TS0 not updated 
                                    offset0 = size(TS0, 2);
                                    
                                    tsInit0(counter) =  tsInit0(counter-1);
                                    tsEnd0(counter) = tsEnd0(counter-1);
                                    tsLengths0(counter) = tsLengths0(counter-1);
                                    
                                    
                                     if isempty(tmpTS1)
                                        % nothing to combine
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                        tsLengths1(counter) = tsLengths1(counter-1);
                                        tsInit1(counter) = tsInit1(counter-1);
                                        tsEnd1(counter)= tsEnd1(counter-1);
                                    else
                                        tmpDataSetStartIndex1 = f_position_on_marginal(DataSet1, tmpTS1(:,end)', DataSetStartIndex1);
                                        TmpSetReduced1 = DataSet1(: , tmpDataSetStartIndex1 + 1 : end);
                                        FDataSetReduced1 = [TS1, tmpTS1, TmpSetReduced1];
                                        
                                        tsLengths1(counter) = ceil(size([TS1, tmpTS1],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                        
                                        TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                        offset1 = size(TS1, 2);
                                        
                                        tsInit1(counter) = tsInit1(counter-1);
                                        % combined set naturally satistifies minTSsize
                                        if tsInit1(counter)==1
                                            tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter)-1 ;
                                        else
                                            tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter);
                                        end
                                        DataSetStartIndex1 =  f_position_on_marginal(DataSet1, TS1(:,end)', DataSetStartIndex1);
                                     end
                                    tmpDataSetStartIndex = tsEnd(counter);
                                    TmpSetReduced = DataSet(: , tmpDataSetStartIndex + 1 : end);
                                    FDataSetReduced = [TS, tmpTS, TmpSetReduced];
                                    
                                    tsLengths(counter) = ceil(size([TS, tmpTS],2) / params.windowWidth) * params.windowWidth;
                                    tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
                                    
                                    tsInit(counter) = tsInit(counter-1);
                                    
                                    TS = FDataSetReduced(:,1:min(size(FDataSetReduced,2),tsLengths(counter)));
                                    offset = size(TS, 2);
                                    
                                    if tsInit(counter)==1
                                        tsEnd(counter)= tsInit(counter) + tsLengths(counter)-1 ;
                                    else
                                        tsEnd(counter)= tsInit(counter) + tsLengths(counter);
                                    end
                                    DataSetStartIndex =  f_position_on_marginal(DataSet, TS(:,end)', DataSetStartIndex);
                            end
                            
                        case 1
                            % only examine h_test1
                            switch  h_test1
                                case 1
                                    'drift confirmed in single C1 detector'
                                    % cell(1,3)
                                    % C1 M retrain
                                    % C0 combine
                                    
                                    % one detector only should not make any differences changed tmpTS = init:end without init+1 
                                    % so we do not need tsInit1(counter) = f_position_on_marginal(DataSet1, tmpTS1(:,1)', DataSetStartIndex1);
                                    DataSetStartIndex1 = tsInit1(counter);
                                    TmpSetReduced1 = DataSet1(: , DataSetStartIndex1 + 1 : end);
                                    FDataSetReduced1 = TmpSetReduced1;
                                    
                                    tsLengths1(counter) = ceil(size(tmpTS1,2) / params.windowWidth) * params.windowWidth;
                                    tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                    tsEnd1(counter) = min([tsInit1(counter) + tsLengths1(counter) , size(DataSet1 , 2)]);
                                    
                                    TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                    offset1 = 0;
                                    
                                    if isempty(tmpTS0)
                                        % nothing to combine
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                        tsLengths0(counter) = tsLengths0(counter-1);
                                        tsInit0(counter) = tsInit0(counter-1);
                                        tsEnd0(counter)= tsEnd0(counter-1);
                                    else
                                        tmpDataSetStartIndex0 = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                        TmpSetReduced0 = DataSet0(: , tmpDataSetStartIndex0 + 1 : end);
                                        FDataSetReduced0 = [TS0, tmpTS0, TmpSetReduced0];
                                        
                                        tsLengths0(counter) = ceil(size([TS0, tmpTS0],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                        
                                        TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                        offset0 = size(TS0, 2);
                                        
                                        tsInit0(counter) = tsInit0(counter-1);
                                        % combined set naturally satistifies minTSsize
                                        if tsInit0(counter)==1
                                            tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter)-1 ;
                                        else
                                            tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter);
                                        end
                                        DataSetStartIndex0 =  f_position_on_marginal(DataSet0, TS0(:,end)', DataSetStartIndex0);
                                    end
                                    
                                    
                                    DataSetStartIndex = tsInit(counter);
                                    TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                    FDataSetReduced = TmpSetReduced;
                                    
                                   
                                    tsLengths(counter) = ceil(size(tmpTS,2) / params.windowWidth) * params.windowWidth;
                                    tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
                                    tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
                                    
                                    TS = TmpSetReduced(:,1:min(size(FDataSetReduced,2),tsLengths(counter)));
                                    offset = 0;
                                case 0
                                    'drift not confirmed in single C1 detector'
                                    % cell(2,3)
                                    % M combine
                                    % C1 no retraining
                                    % C0 combine
                                   
                                    % one detector only should not make any differences changed tmpTS = init:end without init+1 
                                    % so we do not need tsEnd0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                   
                                    DataSetStartIndex1 = tsEnd1(counter);
                                    TmpSetReduced1 = DataSet1(: , DataSetStartIndex1 + 1 : end);
                                    FDataSetReduced1 = [TS1, TmpSetReduced1];
                                    % TS1 not updated 
                                    offset1 = size(TS1, 2);
                                    
                                    tsInit1(counter) =  tsInit1(counter-1);
                                    tsEnd1(counter) = tsEnd1(counter-1);
                                    tsLengths1(counter) = tsLengths1(counter-1);
                                    
                                    
                                     if isempty(tmpTS0)
                                        % nothing to combine
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex0 TmpSetReduced0 offset0 TS0 FDataSetReduced0 all remain the same as the previous iteration
                                        tsLengths0(counter) = tsLengths0(counter-1);
                                        tsInit0(counter) = tsInit0(counter-1);
                                        tsEnd0(counter)= tsEnd0(counter-1);
                                    else
                                        tmpDataSetStartIndex0 = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                        TmpSetReduced0 = DataSet0(: , tmpDataSetStartIndex0 + 1 : end);
                                        FDataSetReduced0 = [TS0, tmpTS0, TmpSetReduced0];
                                        
                                        tsLengths0(counter) = ceil(size([TS0, tmpTS0],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                        
                                        TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                        offset0 = size(TS0, 2);
                                        
                                        tsInit0(counter) = tsInit0(counter-1);
                                        % combined set naturally satistifies minTSsize
                                        if tsInit0(counter)==1
                                            tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter)-1 ;
                                        else
                                            tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter);
                                        end
                                        DataSetStartIndex0 =  f_position_on_marginal(DataSet0, TS0(:,end)', DataSetStartIndex0);
                                     end
                                    
                                    tmpDataSetStartIndex = tsEnd(counter);
                                    TmpSetReduced = DataSet(: , tmpDataSetStartIndex + 1 : end);
                                    FDataSetReduced = [TS, tmpTS, TmpSetReduced];
                                    
                                    tsLengths(counter) = ceil(size([TS, tmpTS],2) / params.windowWidth) * params.windowWidth;
                                    tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
                                    
                                    tsInit(counter) = tsInit(counter-1);
                                    
                                    TS = FDataSetReduced(:,1:min(size(FDataSetReduced,2),tsLengths(counter)));
                                    offset = size(TS, 2);
                                    
                                    if tsInit(counter)==1
                                        tsEnd(counter)= tsInit(counter) + tsLengths(counter)-1 ;
                                    else
                                        tsEnd(counter)= tsInit(counter) + tsLengths(counter);
                                    end
                                    DataSetStartIndex =  f_position_on_marginal(DataSet, TS(:,end)', DataSetStartIndex);
                            end
                            
                        case 2
                            switch  h_testM
                                case 1
                                    
                                    'single marginal confirmed'
                                    % cell(3,1)
                                    
                                    % M C1 C0 all retrained on new set
                                    
                                    
                                    if isempty(tmpTS1)
                                        % nothing to retrain on 
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                        tsLengths1(counter) = tsLengths1(counter-1);
                                        tsInit1(counter) = tsInit1(counter-1);
                                        tsEnd1(counter)= tsEnd1(counter-1);
                                    else
                                        tsInit1(counter) = f_position_on_marginal(DataSet1, tmpTS1(:,1)', DataSetStartIndex1);
                                        tsEnd1(counter) = f_position_on_marginal(DataSet1, tmpTS1(:,end)', DataSetStartIndex1);
                                        
                                        DataSetStartIndex1 = tsInit1(counter);
                                        TmpSetReduced1 = DataSet1(: , DataSetStartIndex1 + 1 : end);
                                        FDataSetReduced1 =  TmpSetReduced1;
                                        
                                        tsLengths1(counter) = ceil(size([tmpTS1],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                        
                                        TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                        offset1 =0;
                                    end
                                    
                                    
                                    if isempty(tmpTS0)
                                        % nothing to combine
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex0 TmpSetReduced0 offset0 TS0 FDataSetReduced0 all remain the same as the previous iteration
                                        tsLengths0(counter) = tsLengths0(counter-1);
                                        tsInit0(counter) = tsInit0(counter-1);
                                        tsEnd0(counter)= tsEnd0(counter-1);
                                    else
                                        tsInit0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,1)', DataSetStartIndex0-10);
                                         tsInit0(counter)
                                        tsEnd0(counter) = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                        
                                        DataSetStartIndex0 = tsInit0(counter);
                                        TmpSetReduced0 = DataSet0(: , DataSetStartIndex0 + 1 : end);
                                        FDataSetReduced0 =  TmpSetReduced0;
                                        
                                        tsLengths0(counter) = ceil(size([tmpTS0],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                        
                                        TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                        offset0 =0;
                                    end
                                    
                                    DataSetStartIndex = tsInit(counter);
                                    TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                    FDataSetReduced = TmpSetReduced;
                                    
                                    tsLengths(counter) = ceil(size(tmpTS,2) / params.windowWidth) * params.windowWidth;
                                    tsLengths(counter) = max([tsLengths(counter), params.MinimumTS_Size]);
                                    tsEnd(counter) = min([tsInit(counter) + tsLengths(counter) , size(DataSet , 2)]);
                                    
                                    TS = FDataSetReduced(:,1:min(size(FDataSetReduced,2),tsLengths(counter)));
                                    offset = 0;
                                case 0
                                    'single marginal not confirmed'
                                    % cell(3,2)
                                    % M not retrained
                                    % C1 C0 combine
                                    
                                    if isempty(tmpTS0)
                                        % nothing to combine
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex0 TmpSetReduced0 offset0 TS0 FDataSetReduced0 all remain the same as the previous iteration
                                        tsLengths0(counter) = tsLengths0(counter-1);
                                        tsInit0(counter) = tsInit0(counter-1);
                                        tsEnd0(counter)= tsEnd0(counter-1);
                                    else
                                        tmpDataSetStartIndex0 = f_position_on_marginal(DataSet0, tmpTS0(:,end)', DataSetStartIndex0);
                                        TmpSetReduced0 = DataSet0(: , tmpDataSetStartIndex0 + 1 : end);
                                        FDataSetReduced0 = [TS0, tmpTS0, TmpSetReduced0];
                                        
                                        tsLengths0(counter) = ceil(size([TS0, tmpTS0],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths0(counter) = max([tsLengths0(counter), params.MinimumTS_Size]);
                                        
                                        TS0 = FDataSetReduced0(:,1:min(size(FDataSetReduced0,2),tsLengths0(counter)));
                                        offset0 = size(TS0, 2);
                                        
                                        tsInit0(counter) = tsInit0(counter-1);
                                        % combined set naturally satistifies minTSsize
                                        if tsInit0(counter)==1
                                            tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter)-1 ;
                                        else
                                            tsEnd0(counter)= tsInit0(counter) + tsLengths0(counter);
                                        end
                                        DataSetStartIndex0 =  f_position_on_marginal(DataSet0, TS0(:,end)', DataSetStartIndex0);
                                    end
                                    if isempty(tmpTS1)
                                        % nothing to combine
                                        % keep everything the way it is and continue testing
                                        % DataSetStartIndex1 TmpSetReduced1 offset1 TS1 FDataSetReduced1 all remain the same as the previous iteration
                                        tsLengths1(counter) = tsLengths1(counter-1);
                                        tsInit1(counter) = tsInit1(counter-1);
                                        tsEnd1(counter)= tsEnd1(counter-1);
                                    else
                                        tmpDataSetStartIndex1 = f_position_on_marginal(DataSet1, tmpTS1(:,end)', DataSetStartIndex1);
                                        TmpSetReduced1 = DataSet1(: , tmpDataSetStartIndex1 + 1 : end);
                                        FDataSetReduced1 = [TS1, tmpTS1, TmpSetReduced1];
                                        
                                        tsLengths1(counter) = ceil(size([TS1, tmpTS1],2) / params.windowWidth) * params.windowWidth;
                                        tsLengths1(counter) = max([tsLengths1(counter), params.MinimumTS_Size]);
                                        
                                        TS1 = FDataSetReduced1(:,1:min(size(FDataSetReduced1,2),tsLengths1(counter)));
                                        offset1 = size(TS1, 2);
                                        
                                        tsInit1(counter) = tsInit1(counter-1);
                                        % combined set naturally satistifies minTSsize
                                        if tsInit1(counter)==1
                                            tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter)-1 ;
                                        else
                                            tsEnd1(counter)= tsInit1(counter) + tsLengths1(counter);
                                        end
                                        DataSetStartIndex1 =  f_position_on_marginal(DataSet1, TS1(:,end)', DataSetStartIndex1);
                                    end
                                    
                                    DataSetStartIndex = tsEnd(counter);
                                    TmpSetReduced = DataSet(: , DataSetStartIndex + 1 : end);
                                    FDataSetReduced = [TS, TmpSetReduced];
                                    % TS not updated
                                    offset = size(TS, 2);
                                    
                                    tsLengths(counter) = tsLengths(counter-1);
                                    tsInit(counter) = tsInit(counter-1);
                                    tsEnd(counter) = tsEnd(counter-1);
                            end
                    end
            end
            
            
            
            
            % size(TmpSetReduced0,2) < params.MinimumTS_Size  || size(TmpSetReduced1,2) < params.MinimumTS_Size||...
            if (size(FDataSetReduced,2) <=  tsLengths(counter) || ...
                    size(FDataSetReduced0,2) <= tsLengths0(counter) ||size(FDataSetReduced1,2) <= tsLengths1(counter))
                detected(counter) = 0;
                %warning('Sollevo un falso negativo perch?il dataset corrisponde al ts')
            end
            % end
            
            % TODO Add reconfiguration phase where we check if the number of
            % samples in the new ts is enough, otherwise we postpone the
            % detection and run another CPM to make sure that all this segment
            % is stationary
            
            %tsLengths
            %tsLengths1
            %tsLengths0
            
            %             tsInit1(counter)
            %             tsEnd1(counter)
            %             tsLengths1
            %             tsInit0(counter)
            %             tsEnd0(counter)
            %             tsLengths0
            %             tsInit(counter)
            %             tsEnd(counter)
            %             tsLengths(counter)
            
            lab = FDataSetReduced(end,:);
            lab0 = FDataSetReduced0(end,:);
            lab1 = FDataSetReduced1(end,:);
            
            DataSetReduced = FDataSetReduced(1:end-1,:);
            DataSetReduced0 = FDataSetReduced0(1:end-1,:);
            DataSetReduced1 = FDataSetReduced1(1:end-1,:);
            
        end
        
    end
    
end


% controllo se per caso non ho avuto una detection proprio all'ultimo campione per cui non posso deifinire il ts
%if tsEnd(end) == length(DataSet)
%    tsInit = tsInit(1 : end);
%    tsEnd = tsEnd(1 : end);
%    tsLengths = tsLengths(1 : end);
%    testDetectingChange = testDetectingChange(1 : end - 1);
%end

% testDetectingChangeInit not defined
%if exist('testDetectingChangeRefinement', 'var')
%    testDetectingChangeInit(detected < 0) = - testDetectingChangeInit(detected < 0);
%    testDetectingChange.Init = testDetectingChangeInit;
%    testDetectingChangeRefinement(detected < 0) = - testDetectingChangeRefinement(detected < 0);
%    testDetectingChange.Refined= testDetectingChangeRefinement;
%end




